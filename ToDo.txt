--> GameState.js which houses games current state, allows for loading/saving, and has current state of player/monsters/npcs/items/etc.

************************************************************************************************************************************************************

--> Inventory (Slots, and then brown bag background to make it look nice)
--> Looting Scene pop-up window (with enemy item drops)
--> Bank (Need chest in game to click on and bank stuff). Store (Need NPC or chest in game to click on and view store menu.)
--> Pause Menu/Controls(Esc key brings up menu options (Load, Save, Options, Esc, etc.) (Options --> Audio/Keybinds/Graphics etc.))
--> Equipment Scene, have an enlarged idling animation of the player on the equip screen, like runescape, and gear slots, and stats on the right. Have small button next to inventory bag with helmet and sword indicating that player can click and that also takes you to equipment scene.
--> Teleporter: =-D
--> Chatbox for console messages.
--> Loading Bar scene after the homescene that loads in assets.

--> (Bonus): Instead of spattackcost and spmanacost stuff in player, do that in playerstate, and define it there in the constructor. (Also the delay timers could be variables in that construcotr maybe)
--> (Bonus): Monster Attack Anims
--> (Bonus): Click to move/Click to initiate attack?
--> (Bonus): Monster Spawn zones instead of just random points.
--> (Bonus): Monster 'wandering' while in idle state? Or new 'wander' state.
--> (Bonus): Defense stat on monsters & player.
--> (Bonus): Debuffs and buffs.
--> (Bonus): Random % Chance for critical, would work with both attack and special attack. Along with crit efficiency (150% for example)
--> (Bonus): You can only save at the inn when you go to sleep.
--> (Bonus): Player and/or monster damage is random (from 0 to maxDamage basically)

--> (Small Refactor): Combine PlayerAttackState and PlayerSpecialAttackState.
--> (Small Refactor): Refactor player stats/methods into a separate file? Player class is getting a bit messy with its stats and methods.
--> (Small Refactor): This line in the playestates for the monster might be useless: "this.player.monstersTouching = this.player.monstersTouching.filter(m => m !== monsterSprite);". Since the object gets completely destroyed anyway, I wonder if that automatically means it leaves the monstersTouching array.

--> (Small Bug): Fix status bar positions during camera zooming.
--> (Small Bug): Multiple Monsters running like idiots at you, pushing you around and not respecting the attackSensor as a stopping place sometimes.
--> (Small Bug): You can 'cheese' the running system and tap shift very fast while moving to conserve stamina. Perhaps a cooldown for the transition.
--> (Small Bug): If you aggro two enemies at once, only one will follow you. (Similar to how if you ran away from two monsters attack range quickly, only 1 would transition to attack state).
--> (Small Bug): For enemy attacking, instead of the timer starting and then waiting 1 second and then performing first attack, have the first attack always be instant at the first instant of touching the player collider and the monster attack sensor, and then start the timer. (Later on making it based off frames just like player attacking could be best.)


Weapon/Armor Sprite and Animation:

--> Different sprites and animations for different weapons. Start with sword and axe, and two colors of each. Different base damages for each weapon.
--> Weapon range distance can be dealt by by turning off and on sensors like you have done for the 'Direction'. It is possible to combine many sensors onto the player and only turn on the ones you want. Also up/down/left/right sensors rather than just left/right. You would have up/down/left/right sensors, and then also a specific weapon sensor which is basically a rectangle, or other shape, with a specific length for that weapon range.
--> Contend with armor wearing using the paper dolling technique. Changing armor doesn't necessarily mean changing animations, but it does change the appearance of the character sprite. Each piece of gear or equipment (head, chest, legs, etc.) would be its own separate sprite or sprite sheet. These are layered on top of a base character sprite, which has its own set of animations (walking, running, etc.). The individual gear sprites can be static (not animated), or they can have their own animations that match up with the base character animations. When the gear is equipped, its sprite is added to the character's sprite at the appropriate layer and position.
--> Contend with weapon wielding sprites by having separate animations for each weapon type.
--> Paper dolling: Separate the weapon from the character, allowing it to be drawn independently. Then you can define a "hand" position in your character animation, and draw the weapon at that position with its own animation. This way, you can mix and match different weapon animations with the same character animation. To make this work, the artist needs to ensure that all the gear sprites align correctly with the base character sprite and its animations. For example, if the character raises their arm during an attack animation, there needs to be an equivalent 'raised arm' sprite for every piece of gear that could be equipped in the 'arm' slot.


Monsters/GameState Thoughts:

ID: May be needed for gamestate.

Currently: Destroy all monsters & references to monsters, and creates them again when you go back to a scene. Working fine.

GameState: When the player leaves a scene by death or moving to Map2, Save all the current monster states. If there are 3/4 monsters, then it would save those 3 monsters, and also it would know that the 4th monster is currently dead and needs to respawn in X seconds, when you re-enter the scene. (respawn timers may have to be global). This requires the use of saving those 3 monsters to a gamestate, and then loading them back in when you re-visit the scene, AND making sure you don't spawn in any other monsters in the meantime. (Would have to explicitly state, spawn in bear1, bear2, ent1, ent2, and it would check if any are missing, and then spawn them in if they are dead)

However, this doesn't necessarily mean you need to create a full-blown "MonsterState" class with getters and setters for every attribute. Depending on your needs, a simpler solution might be sufficient. For example, you could create a "MonsterData" class that simply stores the necessary information about a monster (type, health, position, respawn timer, etc.) in a serializable format. When the player leaves a scene, you could create a MonsterData object for each monster in the scene and store these in an array. When the player re-enters the scene, you could use these MonsterData objects to recreate the monsters in their previous state.

This approach would be somewhat simpler than creating a full MonsterState class, but it would still require a fair amount of work. You would need to modify your Monster and MonsterManager classes to support creating monsters from MonsterData objects, and you would need to ensure that all relevant monster information is correctly saved and loaded.

As for the issue of monster IDs, one possible solution would be to use the index of the monster in the array as its ID. This would allow you to easily identify and manipulate individual monsters, but it could potentially lead to issues if monsters are added or removed from the array in a way that changes the indices of existing monsters.

In the end, the decision of whether or not to implement this feature really comes down to a cost-benefit analysis. If you feel that the improved gameplay experience is worth the additional complexity and development time, then by all means go for it. But if you feel that the benefits are marginal and the effort would be better spent on other features, then it might be best to put this idea on the back burner for now.