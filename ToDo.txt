--> GameState.js which houses games current state, allows for loading/saving, and has current state of player/monsters/npcs/items/etc.

************************************************************************************************************************************************************

--> Inventory (Slots, and then brown bag background to make it look nice)
--> Usable Items (Put potion in bag, allow player to double click to use, hover over the potion gives a tooltip (hp pot, str pot, etc.))
--> Looting Scene pop-up window (with enemy item drops)
--> Bank (Need chest in game to click on and bank stuff). Store (Need NPC or chest in game to click on and view store menu.)
--> Pause Menu/Controls(Esc key brings up menu options (Load, Save, Options, Esc, etc.) (Options --> Audio/Keybinds/Graphics etc.))
--> Equipment Scene, have an enlarged idling animation of the player on the equip screen, like runescape, and gear slots, and stats on the right. Have small button next to inventory bag with helmet and sword indicating that player can click and that also takes you to equipment scene. (Hover over equipment gives stats)
--> Teleporter: =-D
--> Chatbox for console messages.
--> Loading Bar scene after the homescene that loads in assets.

--> (Bonus): Hitsplats on player and monster
--> (Bonus): Monster Attack Anims
--> (Bonus): Click to move/Click to initiate attack?
--> (Bonus): Monster Spawn zones instead of just random points. Would be same dimensions as their wander zone.
--> (Bonus): Monster 'wandering' while in idle state? Or new 'wander' state.
--> (Bonus): Defense stat on monsters & player.
--> (Bonus): Debuffs and buffs.
--> (Bonus): Random % Chance for critical (no anim change, besides hitsplats), would work with both attack and special attack. Along with crit efficiency (150% etc.)
--> (Bonus): You can only save at the inn when you go to sleep.
--> (Bonus): Player and/or monster damage is random (from 0 to maxDamage basically)
--> (Bonus): Monster Attacking Sensor is not a circle but more closely related to their body shape.

--> (Optional): Combine PlayerAttackState and PlayerSpecialAttackState.
--> (Optional): Refactor player stats/methods into a separate file? Player class is messy with its stats and methods.

--> (Small Bug): Fix status bar positions during camera zooming.
--> (Small Bug): Multiple Monsters running like idiots at you, pushing you around and not respecting the attackSensor as a stopping place sometimes.
--> (Small Bug): If you aggro two enemies at once, only one will follow you. (Similar to how if you ran away from two monsters attack range quickly, only 1 would transition to attack state).
--> (Small Bug): Player facing wrong way when entering map. Handle direction in gamestate.


Monsters/GameState Thoughts:

Currently: Destroys all monsters & references to monsters, and creates them again when you go back to a scene. Working fine.

GameState: When the player leaves a scene by dying or simply walking to a new scene, the game would take a snapshot of the monsters current state when the player leaves the scene, and saves each monster's, dead or alive, current state which includes their attributes including hp, other stats, position, isAlive flag, etc. Then, if the player re-enters the scene, it would grab that snapshot and load in the data for each monster. ID may be needed for GameState. 

The whole purpose of this would be if the player has killed some of the monsters in a scene, if he exits the scene and comes back, only the monsters that are still alive are loaded back in, while the others are still waiting for their respawn timer so they can spawn back in. Would also want to force the alive monsters HP to be full again to prevent cheesing.

May not need full-blown "MonsterState" class with getters and setters for every attribute. You could create a "MonsterData" class that simply stores the necessary information about a monster (type, health, position, respawn timer, etc.) in a serializable format. When the player leaves a scene, you could create a MonsterData object for each monster in the scene and store these in an array. When the player re-enters the scene, you could use these MonsterData objects to recreate the monsters in their previous state. You would need to modify your Monster and MonsterManager classes to support creating monsters from MonsterData objects, and ensure that all relevant monster information is correctly saved and loaded.


Weapon/Armor Sprite and Animation:

--> Different sprites and animations for different weapons. Start with sword and axe, and two colors of each. Different base damages for each weapon.
--> Weapon range distance can be dealt by by turning off and on sensors like you have done for the 'Direction'. It is possible to combine many sensors onto the player and only turn on the ones you want. Also up/down/left/right sensors rather than just left/right. You would have up/down/left/right sensors, and then also a specific weapon sensor which is basically a rectangle, or other shape, with a specific length for that weapon range.
--> Contend with armor wearing using the paper dolling technique. Changing armor doesn't necessarily mean changing animations, but it does change the appearance of the character sprite. Each piece of gear or equipment (head, chest, legs, etc.) would be its own separate sprite or sprite sheet. These are layered on top of a base character sprite, which has its own set of animations (walking, running, etc.). The individual gear sprites can be static (not animated), or they can have their own animations that match up with the base character animations. When the gear is equipped, its sprite is added to the character's sprite at the appropriate layer and position.
--> Contend with weapon wielding sprites by having separate animations for each weapon type.
--> Paper dolling: Separate the weapon from the character, allowing it to be drawn independently. Then you can define a "hand" position in your character animation, and draw the weapon at that position with its own animation. This way, you can mix and match different weapon animations with the same character animation. To make this work, the artist needs to ensure that all the gear sprites align correctly with the base character sprite and its animations. For example, if the character raises their arm during an attack animation, there needs to be an equivalent 'raised arm' sprite for every piece of gear that could be equipped in the 'arm' slot.


Inventory:
0. Preserve current visibility across scenes. (Store the visibility state in GameState, accessible to all scenes. When a scene is created/resumed, it checks the GameState for the visibility of the inventory and sets it accordingly.)

1. Manually add an item to the inventory and display it. (Create internal representation of inventory as an array/list of objects. When an item is added to the inventoryData, its sprite would also be added to the inventory display.)

2. Allow for the item to be dragged and moved to different slots.

3. Add other future functionality, like automatically adding an item to an available slot, removing an item from the inventory, etc.

4. Eventually, we'll want the inventory items to be able to be clicked or dragged on to be equipped by the player.


Which methods should be in InventoryDisplay.js and which should be in GameState?

The visual representation of the inventory (the slots, the item sprites, the quantity text, etc.) is derived from this underlying data. 
When you load a new scene, you'll load the saved inventory data, and then use this data to draw the inventory on the screen. 
Or, if you move the sprite from slot 3 to slot 7 for example, it should update the data to let everything know that item is no longer in slot 3, and is now in slot 7.

Scene Transition process:

1. Save the inventory data: When the player leaves a scene, you'll call saveInventoryState to save the current state of the inventory (visibility and data). This will involve getting the current inventory data (using getInventoryData) and storing it in the GameState.
2. Load the inventory data: You'll call loadInventoryState (Probably within the create method of the parent 'Map' class) to load the saved inventory data into the new scene. This will involve setting the inventory data (using setInventoryData) to the saved data from the GameState. From the loaded data, the scene for the inventory will be able to be drawn with all the inventory slots and the item sprites in their correct and current locations.

Extra:
    rightClickDestroy(){
        //If the player right clicks, a small hover screen can come up with the option to remove the item.
    };
    hoverOverStats(){
        // If hovered over an item, displays its name and some text about the item in a small screen.
    };



Ok cool. So I imagine that I'll have an InventoryData.js file which is just a normal class which deals with the inventory data, like which items are where in the inventory, and then I'll have my InventoryDisplay.js file which is a class that extends Phaser.Scene, which is put in my Configs scene array, and launched in my parent scene class 'Map' create section.

I imagine that the inventory data and the inventory display should always be 'talking' to eachother if that makes sense. They should be intimately linked, such that if the data is updated or changed, the inventory display draws that accordingly, and if an item is dragged to a different slot, the data is updated.

And in regard to the gamestate of our game, I imagine that their are two main components to consider. The inventorys current visibility status (is it toggle to visible or invisible), and the inventories current data status (which items are in which slots).

And so I imagine we'll set it up kind of similar to how our player's state is done. We'll have a get and set method for the inventories current visibility, and a get and set method for the inventories current data. We could call them 'getInventoryData', 'setInventoryData', 'getInventoryVisibility', 'setInventoryVisibility'.

And so then we could also have an overall save and load state methods also in the GameState, like 'saveInventoryState' and 'loadInventoryState', which would consider both the current visibilty of the inventory and the current data of the inventory.

We'll also need to contend with how exactly to describe the inventory data. I imagine this will reference each of the 16 slots basically that we created, so it could be an empty object set to null for each of its 16 entries if the inventory is empty.

Synchronization: Keep data and display sycned. Use Observer pattern, where data emits events when its data changes, and display listens for these events and updates the display, and perhaps vice versa.


As for the setInventoryData method, you don't need it in GameState for now because we're not modifying the inventory data from outside the InventoryData class. However, you might need it in the future when you implement item pickup or usage.